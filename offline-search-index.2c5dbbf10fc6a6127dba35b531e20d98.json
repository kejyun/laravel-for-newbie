








































[{"body":"在 docker 我們會建立自己專案的環境，讓他可以運行我們的專案、看是 php、python、golang … 之類的運行環境，而專案會需要定期排程去執行指定的程式，以下以 Laravel 為例\n建立自訂 crontab 檔案 在專案下會建立一個 crontab 指令的檔案 my_laravel_docker_crontab\n每分鐘會切換到 Laravel 專案目錄下 /my/laravel/app/ 並執行 php artisan schedule:run 的指令執行排程\n# my_laravel_docker_crontab # m h dom mon dow command * * * * * cd /my/laravel/app/ \u0026\u0026 php artisan schedule:run \u003e\u003e /dev/null 2\u003e\u00261 環境安裝 cron 映像檔通常是最小單位的檔案，所以不會有 cron 的排程程式，所以在建立 Docker 環境時必須要自己指定去安裝 cron 軟體，這樣就可以在我們自己自定義的環境去跑 cron 定期排程去執行程式\nRUN apt-get update \u0026\u0026 apt-get install -y cron加入自訂的 crontab 檔案 在 docker 專案下將 crontab 指令的檔案 my_laravel_docker_crontab 複製到 docker 的目錄下，並指定 crontab 去執行此 crontab 檔案\n# 加入 docker 專案的自訂 crontabADD my_laravel_docker_crontab /etc/cron.d/my_laravel_docker_crontab# 指定 crontab 檔案RUN crontab /etc/cron.d/my_laravel_docker_crontab執行 crontab 在最後使用指令執行 crontab，這樣就可以開始每分鐘定期執行程式了\n# 執行 crontabCMD [\"cron\", \"-f\"]完整程式碼 以下是完整的 Dockerfile 檔案 laravel.cron.Dockerfile\n# laravel.cron.DockerfileFROMphp:7.4-fpmWORKDIR/varRUN apt-get update \u0026\u0026 apt-get install -y cron libpq-dev libpng-dev libzip-dev zipRUN docker-php-ext-install pgsql pdo_pgsql gd zip\\ \u0026\u0026 docker-php-ext-enable opcache# 加入 docker 專案的自訂 crontabADD my_laravel_docker_crontab /etc/cron.d/my_laravel_docker_crontab# 指定 crontab 檔案RUN crontab /etc/cron.d/my_laravel_docker_crontab# 執行 crontabCMD [\"cron\", \"-f\"]在 docker-compose.yml 檔案會去執行剛剛的 laravel.cron.Dockerfile 檔案，這樣就可以定期去執行 Laravel 的排程程式了\nversion:'3'services:cronjob:container_name:laravel_cronjobbuild:laravel.cron.Dockerfileimage:laravel_cronjob:v1.0volumes:- /home/KJ/laravel_app:/my/laravel/app/restart:always參考資料  cron - docker root crontab job not executing - Stack Overflow laravel-docker-cron/Dockerfile at master · yupmin/laravel-docker-cron Task Scheduling - Laravel - The PHP Framework For Web Artisans  ","categories":["Laravel","教學文件","新手教學","進階","排程","scheduling","Docker"],"description":"Docker 排程","excerpt":"Docker 排程","ref":"/advanced/scheduling/docker/","tags":["Laravel","教學文件","新手教學","進階","排程","scheduling","Docker"],"title":"Docker 排程"},{"body":"一般登入流程 傳統登入方式是透過帳號密碼登入後，透過 cookie 中的 session_id 去與 Server 的 session 資料去做比對，如果有比對到 session 資料的話，會從儲存在 session 中的使用者編號，去資料庫或快取撈取使用者的資料，以達到登入該使用者的流程\n   步驟 流程 用途     1 傳入帳號密碼驗證 驗證帳號密碼是否正確，資料庫是否有此帳號   2 記錄使用者資料及 session_id 到 Session 將登入使用者的資料儲存在 Session，之後其他 Request 可以直接取用，避免敏感資料讓其他使用者資料   3 記錄使用者 session_id 到 Cookie 告訴前端此使用者的身份是誰，之後會透過這個含有 session_id 的 cookie 做驗證   4 透過 session_id 的 Cookie 做其他驗證請求 撈取 Cookie 中的 session_id 驗證 Server 的 Session 是否有此 session_id，沒有的話則表示未登入    帳號登入必要條件 要確認帳號有登入有兩個條件\n 使用者含有 session_id 的 Cookie 存在瀏覽器 Server 的 Session 中有此 session_id  要確保 Client 端的含有 session_id 的 Cookie 一直存在，這樣 Server 才能有 session_id 資料去做驗證\n而且 Server 的 Session 有此 session_id 的使用者資料\nSession 限制 因為 Cookie 是存在使用者自己的瀏覽器端，所以要確保 Client 端的含有 session_id 的 Cookie 一直存在比較容易，看系統安全性的情境，可以將 Cookie 的過期時間設定很長即可，例如 1 年、3 年、5 年之類的，因為存再久也只是存在使用者自己的瀏覽器，對於 Server 是幾乎沒有任何負擔的\n 額外的負擔應該就是每次 Request 都會把 cookie 傳送到 Server，Cookie 越多的話，每個 Request 需要傳送的資料就會越多，造成 Request 變得比較肥大，但這個就是取捨\n 但 Session 因為是存放在 Server 端，所以如果要完整地將使用者資料保留 1 年、3 年、5 年之類的負擔會很大，如果使用者一年只登入一次，我們卻要將他資料保留這麼久都沒用到，而當使用者越來越多達到百萬千萬級時，一個 Session 檔案雖然只有幾 k，但一乘以百萬千萬來說，對於硬體的儲存負擔還是很大的\n所以 Session 的資料通常會依照使用者的情境，不會將 Session 儲存太久\n 記住登入帳號 為了減輕 Server 儲存 Session 的壓力，會在使用者資料表加入一個 remember_token 的欄位，當作幫使用者做重新產生 Session 登入的動作，所以登入流程會變成\n   步驟 流程 用途     1 傳入帳號密碼驗證 驗證帳號密碼是否正確，資料庫是否有此帳號   2 記錄使用者資料及 session_id 到 Session 將登入使用者的資料儲存在 Session，之後其他 Request 可以直接取用，避免敏感資料讓其他使用者資料   3 記錄使用者 session_id 到 Cookie 告訴前端此使用者的身份是誰，之後會透過這個含有 session_id 的 cookie 做驗證   4 產生新的 remember_token 記錄到使用者資料表的 remember_token 欄位 做為之後驗證重新登入用   5 記錄使用者 remember_token 及 user_id 到 Cookie 當 Cookie 中的 session_id 找不到 Session 時，會用 user_id 及 remember_token 去驗證登入   6 透過 session_id 的 Cookie 做其他驗證請求 撈取 Cookie 中的 session_id 驗證 Server 的 Session 是否有此 session_id，沒有的話則表示未登入   7 透過 remember_token 及 user_id 的 Cookie 做重新登入 撈取 Cookie 中的 remember_token 及 user_id，與資料庫做比對，確認是否 token 合法可以正常登入，登入成功重新產生 Session    當 Session 保留時間很短時（例如 20 分鐘），在 Session 移除時，也可以透過 remember_token 的 Cookie 去驗重新登入的動作，並重新產生使用者的 Session，確保存放在 Server 中的 Session 都是近期登入的活躍使用者，確保不會有沒在使用的 Session，也可以讓使用者可以正常登入\nremember_token 安全性 因為只要 Cookie 過期時間設定的夠長，只要一直有 remember_token，則使用者就可以一直無限期的一直不斷的維持登入狀態，這樣可能會有安全性的問題，所以在使用者自己觸發登出時，記得更新儲存在資料庫的 remember_token，讓其他有此 remember_token 的使用者無法繼續登入\n 以 Laravel 記住登入舉例  Laravel 版本 8.x\n 登入紀錄登入帳號 在 Laravel 原生記錄使用者 vendor/laravel/framework/src/Illuminate/Auth/SessionGuard.php 程式中，在 login() 函式的第二個參數是 $remember = false，若傳入 true 則會對使用者進行記錄登入帳號 token 的流程\n// vendor/laravel/framework/src/Illuminate/Auth/SessionGuard.php /** * Log a user into the application. * * @param \\Illuminate\\Contracts\\Auth\\Authenticatable $user * @param bool $remember * @return void */ public function login(AuthenticatableContract $user, $remember = false) { // If the user should be permanently \"remembered\" by the application we will  // queue a permanent cookie that contains the encrypted copy of the user  // identifier. We will then decrypt this later to retrieve the users.  if ($remember) { // 確保資料庫有此 remember_token，若沒有則產生新的  $this-\u003eensureRememberTokenIsSet($user); // 紀錄 remember_token 到 cookie  $this-\u003equeueRecallerCookie($user); } } 在 ensureRememberTokenIsSet() 函式會確保資料庫有產生 remember_token，如果沒有的話則會重新產生一個 remember_token 儲存至資料庫\n產生完 remember_token 後，則呼叫 queueRecallerCookie() 紀錄 remember_token 到 cookie\n紀錄 Remember Token 的 Cookie 在 Laravel 原生記錄 Remember Token vendor/laravel/framework/src/Illuminate/Auth/SessionGuard.php 程式中，在 queueRecallerCookie() 會紀錄此 Rememver Token\n 第 1 個變數 $user-\u003egetAuthIdentifier() 是 user_id 第 2 個變數 $user-\u003egetRememberToken() 是資料庫的 remember_token 第 3 個變數 $user-\u003egetAuthPassword() 是使用的密碼   第 3 個參數在 Laravel 8.x 版本都沒有用到，不確定紀錄這個用途是要幹嘛\n // vendor/laravel/framework/src/Illuminate/Auth/SessionGuard.php /** * Queue the recaller cookie into the cookie jar. * * @param \\Illuminate\\Contracts\\Auth\\Authenticatable $user * @return void */ protected function queueRecallerCookie(AuthenticatableContract $user) { $this-\u003egetCookieJar()-\u003equeue($this-\u003ecreateRecaller( $user-\u003egetAuthIdentifier().'|'.$user-\u003egetRememberToken().'|'.$user-\u003egetAuthPassword() )); } 取得驗證使用者資料 在使用 auth()-\u003euser() 撈取登入使用者資料時，會先使用 Session 試著撈取登入使用者的資料，當撈取不到 Session 中使用者的資料時，如果有 Remember Token，則會使用 Remember Token 去做登入\n// vendor/laravel/framework/src/Illuminate/Auth/SessionGuard.php /** * Get the currently authenticated user. * * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null */ public function user() { // 取得 Session 中的使用者編號，使用 Session 登入  $id = $this-\u003esession-\u003eget($this-\u003egetName()); // First we will try to load the user using the identifier in the session if  // one exists. Otherwise we will check for a \"remember me\" cookie in this  // request, and if one exists, attempt to retrieve the user using that.  if (! is_null($id) \u0026\u0026 $this-\u003euser = $this-\u003eprovider-\u003eretrieveById($id)) { $this-\u003efireAuthenticatedEvent($this-\u003euser); } // 使用 Remember Token 登入使用者（如果有的話）  // If the user is null, but we decrypt a \"recaller\" cookie we can attempt to  // pull the user data on that cookie which serves as a remember cookie on  // the application. Once we have a user we can return it to the caller.  if (is_null($this-\u003euser) \u0026\u0026 ! is_null($recaller = $this-\u003erecaller())) { $this-\u003euser = $this-\u003euserFromRecaller($recaller); if ($this-\u003euser) { $this-\u003eupdateSession($this-\u003euser-\u003egetAuthIdentifier()); $this-\u003efireLoginEvent($this-\u003euser, true); } } return $this-\u003euser; } 參考資料  security - What is the best way to implement “remember me” for a website? - Stack Overflow Implementing Secure User Authentication in PHP Applications with Long-Term Persistence (Login with “Remember Me” Cookies) - Paragon Initiative Enterprises Blog Authentication - Laravel - The PHP Framework For Web Artisans session、cookie與\"記住我的登入狀態\"的功能的實現 | 程式前沿  ","categories":["Laravel","教學文件","新手教學","進階","驗證","Auth","記住登入帳號","Remember Me","session cookie remember me","persistence cookie"],"description":"驗證進階知識: 記住登入帳號","excerpt":"驗證進階知識: 記住登入帳號","ref":"/advanced/auth/remember-me/","tags":["Laravel","教學文件","新手教學","進階","驗證","Auth","記住登入帳號","Remember Me","session cookie remember me","persistence cookie"],"title":"記住登入帳號 Remember Me"},{"body":"","categories":["Laravel","教學文件","新手教學","專案管理","檔案架構"],"description":"檔案架構","excerpt":"檔案架構","ref":"/project-manage/file-structure/","tags":["Laravel","教學文件","新手教學","專案管理","檔案架構"],"title":"檔案架構"},{"body":"傳統的 MVC（Model, View, Controller） 框架，當 Controller 收到請求之後，我們會在 Controller 內直接透過 Model 去撈取資料庫的資料，並在 Controller 做資料驗證、資料整合、快取、商業邏輯判斷…等等的工作。\n當系統越來越大，會發現很多類似的商業邏輯的程式都散在各地，沒有辦法重複再利用，當程式需要異動或修改的時候，就要去搜尋所有程式碼，把許多相同商業邏輯的程式碼去做異動，但需要修改的地方若太多，往往會東漏西漏，導致系統出現錯誤，並造成往後開發的時間成本增加。\n所以我們會想要做到 減少重複的程式碼、提高維護開發的效率，所以將程式碼依照分類及分層抽出獨立控管，讓不同類型的程式專心處理自己相關的商業邏輯，讓開發維護更容易。\n隨著程式架構的演進會發展出更多不同的架構，所以這個設計架構準則也是會隨著時間做演進的。\n 資料處理邏輯分層 架構圖 架構說明 A. 資料控制結構 * Controller (控制器：控制資料流程) * ServiceManager (服務整合管理：組合管理不同 Service 的商業邏輯) * Service (服務：處理商業邏輯) * Repository (資源庫：資料表資料撈取邏輯) * Model (資料庫模型：資料表設定) * Presenter (資料呈現：資料表資料格式呈現轉換) * Combination（資料整合：整理 Repository 資料成資訊） * CombinationManager（複合資料整合管理：整理多個 Service 的資料成資訊） * Checker (檢查器：根據 Controller 所需商業邏輯，驗證不同資料表欄位資料) * Validator (驗證器：資料表欄位資料驗證)    結構名稱 說明     Controller (控制器) 控制資料流程，控制要使用哪些 Service 或 ServiceManager 的商業邏輯，去組合出使用者請求需要的資料，並做資料的資料交易控制 (transaction) ，並使用 Checker 去檢查任何使用者傳進來的資料，確保資料的正確性   ServiceManager (服務整合管理) 協助 Controller 組合不同 Service 的資料成商業邏輯   Service (服務) 處理商業邏輯，組合不同的 Repository 資料成商業邏輯，提供 Controller 或 ServiceManager 存取   Repository (資源庫) 資料表資料撈取邏輯，撈取屬於自己 Model 不同條件下的資料，提供 Service 存取   Model (資料庫模型) 資料庫模型，資料表存取相關設定   Presenter (資料呈現) 資料呈現，協助 Model 做資料呈現轉換   Checker (檢查器) 協助 Controller 做資料驗證，在資料進入到程式邏輯前，都需要經過 Checker 將資料格式做驗證   Validator (驗證器) 協助 Checker 做資料驗證，Validator 只能驗證單一 Model 資料   CombinationManager (複合資料整合管理) 協助整理不同 Service 的複合式資料，若有資料的邏輯判斷需要不同的資料來源，則由 CombinationManager 負責整合處理   Combination （資料整合） 協助整理 Repository 資料成資訊    B.獨立結構 * CacheManager (快取：管理資源快取鍵值及清除快取) * Constant (常數：定義資料狀態名稱) * Support (支援：協助處理獨立邏輯資料處理) * ExceptionCode (例外代碼：例外錯誤代碼定義)    結構名稱 說明     CacheManager (快取) 協助專案資料做快取資料的控制，可以在任何程式邏輯複雜的地方做快取存取控制，並統一清除快取   Constant (常數) 定義並命名所有資料狀態，確保資料值做異動時，不會影響程式邏輯   Support (支援) 協助處理獨立程式邏輯，邏輯沒有被其他任何的函式綁定，可以獨立完成   ExceptionCode (例外代碼) 定義例外代碼，可以統一管控當例外發生錯誤時，回傳的錯誤代碼     架構存取限制  不能跨 2 階層以上存取  Controller 不能存取 Repository Controller 不能存取 Validator Service 不能存取 Model   低階層的不能存取高階層的資料  Model 不能存取 Repository Repository 不能存取 Service Validator 不能存取 Checker   同一個資料類型，不能互相呼叫  避免同一類型類別呼叫，造成 new 物件的時候有無窮迴圈  PostService 存取 UserService，UserService 存取 PostsService 造成無窮迴圈   ServiceManager 不能呼叫 ServiceManager Service 不能呼叫 Service Checker 不能呼叫 Checker Validator 不能呼叫 Validator Repository 不能呼叫 Repository CacheManager 不能呼叫 CacheManager   獨立結構可以在任何一階層去呼叫   架構設計邏輯範例說明 A. 資料控制結構 Controller (控制器)    項目 說明     用途 控制資料流程   可以存取結構 Checker、ServiceManager、Service、DB transaction，所有獨立結構   可以被存取結構 無    處理 HTTP 請求的入口，依照需求呼叫 ServiceManager 或 Service 去做資料的存取，大部分情況呼叫 Service 去組合需要的資料就好，若相同的組合邏輯在不同的 Controller 都有用到，那就使用 ServiceManager 去組合不同的 Service\n要確保所有 Service 商業邏輯都正確跑完才允許對資料做異動，並避免 Transaction 在 Controller 及 Service 被重複呼叫，導致無法正確鎖定資料狀態，所以使用 Controller 當作資料交易（Transaction）的控制點\n\u003c?php class PostController extends Controller { public function __construct( PostServiceManager $PostServiceManager, PostService $PostService, CommentService $CommentService, PostChecker $PostChecker ) { $this-\u003ePostServiceManager = $PostServiceManager; $this-\u003ePostService = $PostService; $this-\u003eCommentService = $CommentService; $this-\u003ePostChecker = $PostChecker; } // 顯示文章  public function show($post_id) { try { // 驗證資料  $input = [ 'post_id' =\u003e $post_id ]; $this-\u003ePostChecker-\u003echeckShow($input); // 撈取文章  $Post = $this-\u003ePostServiceManager-\u003efindPost($post_id); // 撈取文章留言  $Comment = $this-\u003eCommentService-\u003egetCommentByPostId(post_id); } catch (Exception $exception) { throw $exception } } // 更新文章  public function update($post_id) { try { // 驗證資料  $input = request()-\u003eall(); $input['post_id'] = $post_id; $this-\u003ePostChecker-\u003echeckUpdate($input); // 交易開始  DB::beginTransaction(); // 更新文章  $Post = $this-\u003ePostService-\u003eupdate($post_id, $input); // 交易結束  DB::commit(); } catch (Exception $exception) { // 交易失敗  DB::rollBack(); throw $exception } } }  ServiceManager (服務整合管理)    項目 說明     用途 組合管理不同 Service 的商業邏輯   可以存取結構 Service、所有獨立結構   可以被存取結構 Controller    使用不同 Service 撈取資料，將不同資料組合成商業邏輯，供 Controller 做存取\n\u003c?php class PostServiceManager { public function __construct( PostService $PostService, UserService $UserService ) { $this-\u003ePostService = $PostService; $this-\u003eUserService = $UserService; } // 撈取文章資料  public function findPost($post_id){ try { // 撈取文章  $Post = $this-\u003ePostService-\u003efindPost($post_id); // 撈取文章作者資料  $user_id = $Post-\u003euser_id; $Post-\u003euser = $this-\u003eUserService-\u003efindUser($user_id); return $Post; } catch (Exception $exception) { throw $exception } } } Service (服務)    項目 說明     用途 處理商業邏輯   可以存取結構 Repository、所有獨立結構   可以被存取結構 Controller、ServiceManager    使用不同的 Repository 撈取資料，將不同資料組合成商業邏輯\n\u003c?php class PostService { public function __construct( PostRepository $PostRepository, PostTagRepository $PostTagRepository ) { $this-\u003ePostRepository = $PostRepository; $this-\u003ePostTagRepository = $PostTagRepository; } // 撈取文章  public function findPost($post_id) { try { // 撈取文章  $Post = $this-\u003ePostRepository-\u003efind($post_id); // 撈取文章標籤  $Tag = $this-\u003ePostTagRepository-\u003egetByPostId($post_id); return [$Post, $Tag]; } catch (Exception $exception) { throw $exception } } }  Repository (資源庫)    項目 說明     用途 資料表資料撈取邏輯   可以存取結構 Model、所有獨立結構   可以被存取結構 Service    撈取特定 Model 資料，像 PostRepository 可以存取 Post Model (模型) 的 基本資料，並使用不同條件撈取 Model 的資料，供 Service 做存取\n也可以使用 PostRecommendRepository 存取 Post Model (模型) 的 推薦資料\n同一個 Model (模型) 可以用不同的 Repository 去呼叫，但同一 Repository 只能有一個 Model (模型)\n\u003c?php class PostRepository { public function __construct( Post $Post ) { $this-\u003ePost = $Post; } public function find($post_id) { try { // 撈取資料庫文章資料  $Post = $this-\u003ePost-\u003efind($post_id); return $Post; } catch (Exception $exception) { throw $exception } } public function findLatestPost() { try { // 撈取資料庫文章資料  $Post = $this-\u003ePost -\u003eorder('created_at', 'desc') -\u003efirst(); return $Post; } catch (Exception $exception) { throw $exception } } } Model (資料庫模型)    項目 說明     用途 資料表設定   可以存取結構 所有獨立結構   可以被存取結構 Repository    Eloquent 存取資料表相關設定，使用 Eloquent 直接存取資料表資料\n\u003c?php class Post extends Model { protected $table = 'post'; protected $fillable = []; protected $primaryKey = 'id'; protected $dates = ['created_at', 'updated_at']; protected $presenter = PostPresenter::class; }  Presenter (資料呈現)    項目 說明     用途 資料表資料格式呈現轉換   可以存取結構 所有獨立結構   可以被存取結構 Model    提供 Model 的資料用其他方式呈現\n\u003c?php class PostPresenter extends Presenter { public function created_at_human_time() { return $this-\u003ecreated_at-\u003ediffForHumans(); } } Checker (檢查器)    項目 說明     用途 根據 Controller 所需商業邏輯，驗證不同資料表欄位資料   可以存取結構 Validator、所有獨立結構   可以被存取結構 Controller    協助 Controller 驗證不同資料表資料的正確性，若驗證錯誤則丟處例外，Controller 根據例外代碼去做處理\n\u003c?php class PostValidator { public function checkFindPost($input){ // 驗證文章資料  $this-\u003ePostValidator-\u003evalidatePostId($input); $this-\u003ePostValidator-\u003evalidatePostContent($input); // 驗證會員資料  $this-\u003eMemberValidator-\u003evalidateMemberId($input); } } Validator (驗證器)    項目 說明     用途 資料表欄位資料驗證   可以存取結構 所有獨立結構   可以被存取結構 Checker    協助 Checker 驗證資料的正確性，若驗證錯誤則丟處例外，Checker 根據例外代碼去做處理\n\u003c?php class PostValidator { public function validatePostId($input){ // 設定驗證規則  $rules = [ 'post_id' =\u003e [ 'required', 'max:20', ], ]; // 開始驗證  $this-\u003evalidator = Validator::make($input, $rules); if ($this-\u003evalidator-\u003efails()) { throw new Exception( '文章編號格式錯誤', PostExceptionCode::POST_ID_FORMAT_ERROR ); } } }  Combination（資料整合）    項目 說明     用途 整理 Repository 資料成資訊   可以存取結構 所有獨立結構   可以被存取結構 Serivce、CombinationManager    當 Service 從 Repository 取得資料後，協助整理判斷 Repository 資料的屬性狀態，像是可以從 文章編號 取得 文章網址\n\u003c?php class PostsCombination { // 設定整合資訊  public function setCombinationInfo(\u0026$Posts) { if (!($Posts instanceof Posts)) { return false; } // 文章網址  $url = url(\"article/{$Posts-\u003eid}\") $Posts-\u003einfo-\u003eurl = $url; } } CombinationManager（複合資料整合管理）    項目 說明     用途 整理多個 Service 的資料成資訊   可以存取結構 Combination、Serivce、所有獨立結構   可以被存取結構 ServiceManager、Controller    當整合的資料需要經過不同的資料來源去判斷要產生什麼複合資訊，CombinationManager 協助整理不同來源的資料去做資料整合，目前會從 ServiceManager 去取得不同 Service 的資訊，所以將 CombinationManager 放在這一階層去進行呼叫\n\u003c?php class PostsCombinationManager { protected $UserService; public function __construct( UserCombination $UserCombination, ProjectService $ProjectService ) { // 服務  $this-\u003eUserCombination = $UserCombination; } public function setCombinationInfo(\u0026$combination_data) { $Posts = array_get($combination_data, 'Posts'); if ($Posts instanceof Posts) { // 設定文章關聯作者資訊  $this-\u003eUserCombination-\u003esetCombinationInfo($Posts-\u003eUser); // 是專題文章  if ($Posts-\u003etype == PostsConstant::TYPE_PROJECT) { $Project = $this-\u003eProjectService-\u003efindProjectByPostId($Posts-\u003eid); $url = url(\"project/{$Project-\u003eslug}/{$Posts-\u003eid}\") $Posts-\u003einfo-\u003eurl = $url; }; } } }  B.獨立結構 CacheManager (快取)    項目 說明     用途 管理資源快取鍵值及清除快取   可以存取結構 x   可以被存取結構 無限制    在 複雜 的資料庫查詢（Repository）或是商業邏輯（Service、ServiceManager），想要在一定時間內不要再重複的進行複雜的運算，可以透過快取將運算的結果快取起來\nPostsCacheManager 文章資源庫\nclass PostRepository { public function __construct( Post $Post, PostsCacheManager $PostsCacheManager ) { $this-\u003ePost = $Post; $this-\u003ePostsCacheManager = $PostsCacheManager; } public function find($post_id) { try { $cache_key = $this-\u003ePostsCacheManager-\u003egetPostIdCacheKey($post_id); $Posts = $this-\u003ePostsCacheManager-\u003egetCache($cache_key); if (!is_null($Posts)) { return $Posts; } // 撈取資料庫文章資料  $Posts = $this-\u003ePost-\u003efind($post_id); if (!is_null($Posts)) { // 有該資料，將資料存入快取  $this-\u003ePostsCacheManager-\u003eputCache($Posts, $cache_key); } return $Posts; } catch (Exception $exception) { throw $exception } } public function findLatestPost() { try { // 撈取資料庫文章資料  $Post = $this-\u003ePost -\u003eorder('created_at', 'desc') -\u003efirst(); return $Post; } catch (Exception $exception) { throw $exception } } } PostsCacheManager 文章快取\nclass PostsCacheManager { protected $cache_key = [ // 文章快取  'post_id' =\u003e '[PostById][post_id:{post_id}]', // 已發布文章快取  'published_post_id' =\u003e '[PublishedPostById][post_id:{post_id}]', ]; /** * 文章快取 */ public function getPostIdCacheKey($post_id) { $search = [ '{post_id}', ]; $replace = [ $post_id, ]; $cache_key = str_replace($search, $replace, $this-\u003ecache_key['post_id']); return $cache_key; } /** * 已發布文章快取 */ public function getPublishedPostIdCacheKey($post_id) { $search = [ '{post_id}', ]; $replace = [ $post_id, ]; $cache_key = str_replace($search, $replace, $this-\u003ecache_key['published_post_id']); return $cache_key; } /** * 文章快取 */ public function getPostIdCacheKey($post_id) { $search = [ '{post_id}', ]; $replace = [ $post_id, ]; $cache_key = str_replace($search, $replace, $this-\u003ecache_key['post_id']); return $cache_key; } /** * 清除文章快取 */ public function forgetPostsCache($cache_data) { $Posts = array_get($cache_data, 'Posts'); if (!is_null($Posts) AND ($Posts instanceof Posts)) { $cache_key = $this-\u003egetPostIdCacheKey($post_id); $is_cache_forget = $Cache::forget($cache_key); $cache_key = $this-\u003egetPublishedPostIdCacheKey($post_id); $is_cache_forget = $Cache::forget($cache_key); // .... 清除文章其他快取  } } }  Constant (常數)    項目 說明     用途 定義資料狀態名稱   可以存取結構 x   可以被存取結構 無限制    資料皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n\u003c?php class PostConstant { const POST_TYPE_PUBLIC = 'P'; const POST_TYPE_DELETE = 'D'; } Support (支援)    項目 說明     用途 協助處理獨立邏輯資料處理   可以存取結構 x   可以被存取結構 無限制    方法皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n若有其他可供全域共用的方法皆寫在 Support 靜態方法供大家存取\n\u003c?php class PostSupport { // 撈取所有文章類型  public static function getAllPostType() { $all_post_type = [ PostConstant::POST_TYPE_PUBLIC, PostConstant::POST_TYPE_DELETE, ]; return $all_post_type; } }  ExceptionCode (例外代碼)    項目 說明     用途 例外錯誤代碼定義   可以存取結構 x   可以被存取結構 x    資料皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n\u003c?php class PostExceptionCode { const POST_ID_FORMAT_ERROR = 10000001; const POST_NOT_FOUND = 10000002; const POST_TAG_NOT_FOUND = 10000003; } View (視圖) 使用限制 View 的職責是負責顯示資料，所有的資料應由 Controller 準備好再傳給 View，所以不要在 View 內有複雜的程式判斷邏輯，在 View 裡面只有 if, for, foreach 跟 echo 列印 的程式，僅需要將資料呈現在對的 HTML 裡面，不要再對資料重複處理過。\n像是文章的網址可能會因為類型不同會有不同的網址，像是一般文章網址可能為 http://kejyun.com/post/1，而影音文章網址可能為 http://kejyun.com/video/2，兩者的資料皆為 Post 資料表的資料，在 View 中要顯示網址應為 echo $Post-\u003epost_url; 將網址印出，post_url 則是在傳給 View 之前就經過邏輯判斷的資料，而不是在 View 中判斷不同文章類型（PostConstant::POST_TYPE_NORMAL, PostConstant::POST_TYPE_VIDEO）在 View 中顯示不同的網址資料。\n之後若文章網址邏輯需要修改，則需要到各個 View 中去修改，很容易漏改道造成系統程式出錯\n\u003ca href=\"{{ $Post-\u003einfo-\u003epost_url }}\"\u003e {{ $Post-\u003eTitle }}\u003c/a\u003e ","categories":["Laravel","教學文件","新手教學","專案管理","檔案架構"],"description":"Combination \u0026 Cache 架構設計準則(2019)","excerpt":"Combination \u0026 Cache 架構設計準則(2019)","ref":"/project-manage/file-structure/combination-cache-manager-structure-principle/","tags":["Laravel","教學文件","新手教學","專案管理","檔案架構"],"title":"Combination \u0026 Cache 架構設計準則(2019)"},{"body":"","categories":["Laravel","教學文件","新手教學","進階"],"description":"進階","excerpt":"進階","ref":"/advanced/","tags":["Laravel","教學文件","新手教學","進階"],"title":"進階"},{"body":"","categories":["Laravel","教學文件","新手教學","專案管理"],"description":"專案管理","excerpt":"專案管理","ref":"/project-manage/","tags":["Laravel","教學文件","新手教學","專案管理"],"title":"專案管理"},{"body":"","categories":["Laravel","教學文件","新手教學","進階","驗證","Auth"],"description":"驗證進階知識","excerpt":"驗證進階知識","ref":"/advanced/auth/","tags":["Laravel","教學文件","新手教學","進階","驗證","Auth"],"title":"驗證 Auth"},{"body":"","categories":["Laravel","教學文件","新手教學","進階","排程","scheduling"],"description":"排程進階知識","excerpt":"排程進階知識","ref":"/advanced/scheduling/","tags":["Laravel","教學文件","新手教學","進階","排程","scheduling"],"title":"排程 scheduling"},{"body":"  #td-cover-block-0 { background-image: url(/hugo-background-1_hu326f4ef6b66b123339657b072010ff80_47161_960x540_fill_catmullrom_bottom_2.png); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/hugo-background-1_hu326f4ef6b66b123339657b072010ff80_47161_1920x1080_fill_catmullrom_bottom_2.png); } }  Laravel for newbie Laravel 菜雞踩雷學習筆記        記錄學習 Laravel 遇到各種不同的系統狀況處理紀錄\n   ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: url(/hugo-background-1_hu326f4ef6b66b123339657b072010ff80_47161_960x540_fill_catmullrom_bottom_2.png); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: …","ref":"/","tags":"","title":"Laravel for newbie"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/docker/","tags":"","title":"Docker"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/docker/","tags":"","title":"Docker"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/laravel/","tags":"","title":"Laravel"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/laravel/","tags":"","title":"Laravel"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/scheduling/","tags":"","title":"scheduling"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/scheduling/","tags":"","title":"scheduling"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E6%8E%92%E7%A8%8B/","tags":"","title":"排程"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%8E%92%E7%A8%8B/","tags":"","title":"排程"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E6%95%99%E5%AD%B8%E6%96%87%E4%BB%B6/","tags":"","title":"教學文件"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%95%99%E5%AD%B8%E6%96%87%E4%BB%B6/","tags":"","title":"教學文件"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8/","tags":"","title":"新手教學"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8/","tags":"","title":"新手教學"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E9%80%B2%E9%9A%8E/","tags":"","title":"進階"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E9%80%B2%E9%9A%8E/","tags":"","title":"進階"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/auth/","tags":"","title":"Auth"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/auth/","tags":"","title":"Auth"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/persistence-cookie/","tags":"","title":"persistence cookie"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/persistence-cookie/","tags":"","title":"persistence cookie"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/remember-me/","tags":"","title":"Remember Me"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/remember-me/","tags":"","title":"Remember Me"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/session-cookie-remember-me/","tags":"","title":"session cookie remember me"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/session-cookie-remember-me/","tags":"","title":"session cookie remember me"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%B0%88%E6%A1%88%E7%AE%A1%E7%90%86/","tags":"","title":"專案管理"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%B0%88%E6%A1%88%E7%AE%A1%E7%90%86/","tags":"","title":"專案管理"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E6%AA%94%E6%A1%88%E6%9E%B6%E6%A7%8B/","tags":"","title":"檔案架構"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%AA%94%E6%A1%88%E6%9E%B6%E6%A7%8B/","tags":"","title":"檔案架構"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E8%A8%98%E4%BD%8F%E7%99%BB%E5%85%A5%E5%B8%B3%E8%99%9F/","tags":"","title":"記住登入帳號"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E8%A8%98%E4%BD%8F%E7%99%BB%E5%85%A5%E5%B8%B3%E8%99%9F/","tags":"","title":"記住登入帳號"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E9%A9%97%E8%AD%89/","tags":"","title":"驗證"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E9%A9%97%E8%AD%89/","tags":"","title":"驗證"}]